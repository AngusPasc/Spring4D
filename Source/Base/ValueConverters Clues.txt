1. Use GetTypeName insteading of string(value.TypeInfo.Name) since it is utf8 string. - DONE
2. Use DoXXX for protected methods. - DONE
3. since TValue could be empty we need to handle this.
4. TNullableValueConverter should be generic. (check out the Spring.TryGetUnderlyingValue, etc.) - DONE
------------------------------------- NEXT STAGE ------------------------------------------------------
1. does a converter really need convertTo and convertBack methods? (or is that better that just a ConvertTo method)
2. what is the reponsiblities of a value converter factory

3. and I found there are depnedencies between TNullableValueConverter (or some else) and the default converter instance.
 this could be better
 and there are so many if-else statements in the default converter.
 I think this could be done better
------------------------------------- NEXT STAGE ------------------------------------------------------
1. CreateResFmt - DONE
2. including object - interface acc. to #82433 TValue.TryAsType<T> raised an AV because ConvClass2Intf is wrong - DONE
3. unicodestring - widestring acc. to #82487 Rtti.ConvStr2Str is wrong (when cast a unicode string to widestring) - DONE
4. if Result.IsEmpty then
    raise Exception.Create(Format(SCouldNotConvertValue,
      [value.TypeInfo.Name, targetTypeInfo.Name])); - DONE
   what about value = nil and targetTypeInfo = nil ?
5. function TValueConverter.ConvertTo(const value: TValue;
   	const targetTypeInfo: PTypeInfo;
  	const parameter: TValue): TValue; - DONE

   what about value = nil and targetTypeInfo = nil ?

